{"version":3,"sources":["forms.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"forms.js","sourcesContent":["/*! Form validation - v1.1.1 - 2014-04-09\n * https://github.com/bboyle/form-validation\n * Copyright (c) 2014 Ben Boyle; Licensed MIT */\n(function( $ ) {\n    'use strict';\n\n\n    var SUBMIT_TOLERANCE = 10000, // milliseconds\n\n        DEFAULT_STATUS_HTML = '<div class=\"status warn\"><div class=\"inner\"><h2>Please check your answers</h2><ol></ol></div></div>',\n\n    // fields that validate\n        candidateForValidation = 'input, select, textarea',\n\n\n    // invalidFilter\n        invalidFilter = function() {\n            return ! ( this.disabled || this.validity.valid );\n        },\n\n\n    // follow plugin conventions for storing plugin data\n    // http://docs.jquery.com/Plugins/Authoring#Data\n        pluginDataKey = 'formValidation',\n        pluginData = function( key, value ) {\n            var dataHash = this.data( pluginDataKey ) || this.data( pluginDataKey, {}).data( pluginDataKey );\n\n            if ( typeof key !== 'undefined' ) {\n                if ( typeof value !== 'undefined' ) {\n                    dataHash[ key ] = value;\n                    return value;\n\n                } else if ( typeof dataHash[ key ] !== 'undefined' ) {\n                    return dataHash[ key ];\n                }\n                return null;\n            }\n\n            return dataHash;\n        },\n\n\n    // helper for .label, .hint and .alert\n        getLabelComponent = function( component, options ) {\n            return this.map(function( index, domElement ) {\n\n                var $element = $( domElement ),\n                    labelElement = null,\n                    foundElement = null;\n\n                if ( typeof options === 'object' && options.level === 'group' ) {\n                    foundElement = $element.formValidation( 'group' ).find( component )[ 0 ];\n\n                } else if ( $element.is( ':radio, :checkbox' )) {\n                    foundElement = $element.closest( 'fieldset' ).find( component )[ 0 ];\n\n                } else {\n                    labelElement = $element.closest( 'form' ).find( 'label[for=\"' + domElement.id + '\"]' );\n                    foundElement = labelElement.children( component )[ 0 ];\n                    if ( ! foundElement ) {\n                        if ( component === '.hint' ) {\n                            labelElement.append( '<small class=\"hint\"></small>' );\n                            foundElement = labelElement.children( component )[ 0 ];\n                        }\n                    }\n                }\n\n                return foundElement;\n\n            });\n        },\n\n\n        changeValidityCheck = function() {\n\n            var $this = $( this ),\n                alertElement = $this.formValidation( 'alert' ),\n                alertLevel,\n                invalidContainers\n                ;\n\n            // is this control valid?\n            if ( this.validity.valid ) {\n\n                // is it part of a group that contain other invalid controls?\n                if ( $this.formValidation( 'question' ).find( '.alert' ).filter( alertElement ).length > 0 ) {\n                    alertElement.remove();\n                } else {\n                    // update message from first invalid field in group\n                    invalidContainers = $this.formValidation( 'group' ).find( candidateForValidation ).filter( invalidFilter );\n                    if ( invalidContainers.length > 0 ) {\n                        alertElement.text( invalidContainers.formValidation( 'getValidationMessage' ));\n                    } else {\n                        // all fields valid\n                        alertElement.remove();\n                    }\n                }\n\n                // remove invalid class from ancestors that do not contain invalid fields\n                $this.parentsUntil( 'form', '.invalid' ).filter(function() {\n                    return $( this ).find( candidateForValidation ).filter( invalidFilter ).length === 0;\n                })\n                // remove .invalid class\n                    .removeClass( 'invalid' )\n                    // remove old alerts (change handler should have already done this)\n                    .find( '.alert' ).remove()\n                ;\n\n            } else {\n\n                // does alert exist?\n                if ( alertElement.length === 0 ) {\n                    alertElement = $( '<em class=\"alert\"/>' );\n                }\n\n                // show message\n                alertElement.text( $this.formValidation( 'getValidationMessage' ));\n                // append to form\n                if ( $this.formValidation( 'group' ).hasClass( 'atomic' )) {\n                    alertLevel = { 'level' : 'group' };\n                }\n\n                $this.formValidation( 'label', alertLevel ).parent().find( '.label, abbr[title=\"(required)\"]' ).eq( -1 ).after( alertElement );\n\n                // NOTE we don't flag the question as .invalid now\n                // .invalid only happens on submit, to soften inline validation errors\n            }\n        },\n\n\n    // checks for invalid elements\n    // returns number of invalid elements\n        submitValidityCheck = function() {\n\n            // form object\n            var form = $( this ).closest( 'form' ),\n\n            // invalid fields\n                invalid = form.find( candidateForValidation ).filter(function invalidFields() {\n\n                    // skip disabled\n                    if ( this.disabled ) {\n                        return false;\n                    }\n\n                    // only check radio button groups once (skip individual radio button)\n                    if ( this.type === 'radio' ) {\n                        if ( ! invalidFields.cache ) {\n                            invalidFields.cache = {};\n\n                        } else if ( invalidFields.cache[ this.name ] === true ) {\n                            return false;\n                        }\n                        invalidFields.cache[ this.name ] = true;\n                    }\n\n                    return this.validity && ! this.validity.valid;\n                }),\n\n            // alert container\n                alert = pluginData.call( form, 'summaryElement' ) || pluginData.call( form, 'summaryElement', $( DEFAULT_STATUS_HTML )),\n\n            // messages within alert\n                messages = alert.find( 'ol' ),\n\n            // track groups\n                lastGroupSeen = true\n                ;\n\n            if ( invalid.length > 0 ) {\n\n                // remove old messages\n                messages.find( 'li' ).remove();\n\n                // add new messages\n                invalid.each(function() {\n\n                    // get field\n                    var $this = $( this ),\n                    // get group (if exists)\n                        group = $this.formValidation( 'group' ),\n                    // get label or group label\n                        label = $this.formValidation( 'label', {\n                            level : group.length > 0 ? 'group' : null\n                        }),\n                        labelId,\n                        item\n                        ;\n\n                    // get the label id\n                    if ( label.length > 0 ) {\n                        labelId = label[ 0 ].id || label.generateId( 'label-' + this.id )[ 0 ].id;\n                    } else {\n                        labelId = this.name;\n                    }\n\n                    // get alert item\n                    item = pluginData.call( $this, 'summaryElement' ) || pluginData.call( $this, 'summaryElement', $( '<li><a href=\"#' + labelId + '\"></a></li>' ));\n\n                    if ( group.length === 0 || group[ 0 ] !== lastGroupSeen ) {\n\n                        // update last group seen\n                        lastGroupSeen = group[ 0 ];\n\n                        // create error message with link to label\n                        item\n                            .find( 'a' )\n                            .text( label.text().replace( /\\?$/, '' ) + ': ' + $this.formValidation( 'getValidationMessage' ))\n                            .end()\n                            .appendTo( messages )\n                        ;\n\n                    } else {\n                        // remove from DOM\n                        item.remove();\n                    }\n                });\n            }\n\n            return invalid.length;\n        },\n\n\n        submitValidationHandler = function( event ) {\n            // validate form\n            var count = submitValidityCheck.call( this ),\n                form = $( this );\n\n            // remove invalid class from questions that do not contain invalid fields\n            form.find( '.invalid' ).filter(function() {\n                return $( this ).find( candidateForValidation ).filter( invalidFilter ).length === 0;\n            })\n            // remove .invalid class\n                .removeClass( 'invalid' )\n                // remove old alerts (change handler should have already done this)\n                .find( '.alert' ).remove()\n            ;\n\n\n            // anything invalid?\n            if ( count > 0 ) {\n                // cancel submit\n                event.stopImmediatePropagation();\n                event.preventDefault();\n\n                // show the error summary\n                (function( form ) {\n                    var summary = pluginData.call( form, 'summaryElement' );\n                    // hide any previous status blocks\n                    form.prev( '.status' ).not( summary ).remove();\n                    // show the new summary\n                    form.before( summary.fadeIn() );\n                    // focus/scroll summary element\n                    $( window ).scrollTop( summary.offset().top );\n                }( form ));\n\n                // find all the invalid fields\n                form.find( candidateForValidation ).filter( invalidFilter ).each(function() {\n                    // update inline alerts\n                    changeValidityCheck.call( this );\n                })\n                // set .invalid on ancestor LI elements\n                    .parentsUntil( 'form', '.questions > li' )\n                    // but not sections\n                    .not( '.section, .compact' )\n                    .addClass( 'invalid' )\n                ;\n\n                // trigger x-invalid\n                form.trigger( 'x-invalid' );\n\n                // cancel submit\n                return false;\n            }\n        },\n\n\n    // bind this AFTER the validation handler\n    // only invoked if validation did not prevent submit\n        submitDoneHandler = function( event ) {\n            // use event.timeStamp when available and $.now() otherwise\n            var timeStamp = event.timeStamp || $.now(),\n                form = $( this ),\n                summaryElement = pluginData.call( form, 'summaryElement' ),\n                lastSubmitTimeStamp\n                ;\n\n            // remove summary element from DOM on successful submit\n            if ( summaryElement ) {\n                summaryElement.remove();\n            }\n\n            // is this submit event too soon after the last one?\n            lastSubmitTimeStamp = pluginData.call( form, 'lastSubmitTimeStamp' );\n            if ( lastSubmitTimeStamp && timeStamp - lastSubmitTimeStamp < SUBMIT_TOLERANCE ) {\n                // cancel the submit event\n                event.stopImmediatePropagation();\n                event.preventDefault();\n                return false;\n\n            } else {\n                // store the timestamp\n                pluginData.call( form, 'lastSubmitTimeStamp', timeStamp );\n            }\n        },\n\n\n    // plugin methods\n        methods = {\n\n            // $( x ).formValidation( 'alert' ) -- get\n            // get alert text\n            alert : function() {\n                return this.map(function( index, domElement ) {\n\n                    var $element = $( domElement ),\n                        group;\n\n                    if ( $element.is( ':radio, :checkbox' ) === true ) {\n                        return $element.closest( 'fieldset' ).find( 'legend > .alert' )[ 0 ];\n\n                    } else {\n                        // atomic groups\n                        group = $element.formValidation( 'group' ).filter( '.atomic' );\n                        if ( group.length > 0 ) {\n                            return group.find( 'legend > .alert' )[ 0 ];\n\n                        } else {\n                            return $( 'label[for=\"' + domElement.id + '\"] > .alert' )[ 0 ];\n                        }\n                    }\n                });\n            },\n\n\n            // $( x ).formValidation( 'label' )\n            // $( x ).formValidation( 'label', { level : group })\n            // return .label associated with element or containing group\n            label : function( options ) {\n                return getLabelComponent.call( this, '.label', options );\n            },\n\n\n            // $( x ).formValidation( 'hint' )\n            // $( x ).formValidation( 'hint', { level : group })\n            // return .hint associated with element or containing group\n            hint : function( options ) {\n                return getLabelComponent.call( this, '.hint', options );\n            },\n\n\n            // $( x ).formValidation( 'question' )\n            // return question element for item\n            question : function( options ) {\n                // looking for group?\n                if ( typeof options === 'object' && options.level === 'group' ) {\n                    // return the group\n                    return this.formValidation( 'group' );\n                }\n\n                // not looking for group\n                return this.map(function( index, domElement ) {\n                    return $( domElement ).parentsUntil( 'form', '.questions > li' )[ 0 ];\n                });\n            },\n\n\n            // $( x ).formValidation( 'group' )\n            // return group element for item\n            group : function() {\n                return this.map(function( index, domElement ) {\n                    return $( domElement ).parentsUntil( 'form', '.group' ).filter(function() {\n                        // ignore groups that do not contain fieldsets\n                        return $( this ).children( 'fieldset' ).length > 0;\n                    })[ 0 ];\n                });\n            },\n\n\n            // $( x ).formValidation( 'validate' )\n            // binds validation handler functions\n            // sets @novalidate on form to disable built-in validation\n            // TODO allow this to be called multiple times without binding additional handlers!\n            validate : function() {\n                return this.each(function() {\n                    $( this ).closest( 'form' )\n                    // turn off native validation\n                        .attr( 'novalidate', true )\n                        // unbind and rebind handlers\n                        .unbind( 'submit', submitDoneHandler )\n                        .unbind( 'submit', submitValidationHandler )\n                        // validate this form\n                        .bind( 'submit', submitValidationHandler )\n                        // if validation did not cancel submit…\n                        .bind( 'submit', submitDoneHandler )\n                        // bind inline validation handlers to form elements\n                        .find( candidateForValidation )\n                        .unbind( 'change', changeValidityCheck )\n                        .bind( 'change', changeValidityCheck )\n                    ;\n                });\n            },\n\n\n            // $( x ).formValidation( 'getValidationMessage' )\n            // return String validation message, e.g. \"Must be completed\"\n            getValidationMessage : function() {\n\n                var validityState = this[ 0 ].validity;\n\n                if ( typeof validityState === 'undefined' || validityState.valid === true ) {\n                    return '';\n\n                } else if ( validityState.valueMissing ) {\n                    return 'Must be completed';\n\n                } else if ( validityState.customError ) {\n                    return this[ 0 ].validationMessage;\n\n                } else if ( validityState.typeMismatch ) {\n                    return 'Must be an email address';\n\n                } else if ( validityState.patternMismatch ) {\n                    return 'Must use the format shown';\n\n                } else {\n                    return 'Must be a valid answer';\n                }\n            }\n\n        };\n\n\n    $.fn.formValidation = function( method ) {\n\n        // Method calling logic\n        // http://docs.jquery.com/Plugins/Authoring#Plugin_Methods\n        if ( methods[method] ) {\n            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));\n        } else if ( typeof method === 'object' || ! method ) {\n            return methods.init.apply( this, arguments );\n        } else {\n            $.error( 'Method ' +  method + ' does not exist on jQuery.formValidation' );\n        }\n\n    };\n\n\n    // legacy API\n    $.fn.forcesForms = $.fn.formValidation;\n\n\n}( jQuery ));\n/*! Generate ID - v1.0.3 - 2014-09-18\n * https://github.com/bboyle/Generate-ID\n * Copyright (c) 2014 Ben Boyle; Licensed MIT */\n(function( $ ) {\n    'use strict';\n\n\n    /**\n     * Assigns a unique value to `@id` unless hasAttribute( 'id' ) is true\n     *\n     * @param preferredId string to use for id value\n     *\n     * @return jquery object (chaining supported)\n     */\n    $.fn.generateId = function( preferredId ) {\n\n        var i = 1;\n\n        if ( ! preferredId ) {\n            preferredId = 'id';\n        } else {\n            preferredId = $.trim( preferredId.toLowerCase().replace( /[^a-z0-9_]+/g, ' ' )).replace( /\\s+/g, '-' );\n        }\n\n        return this.each(function() {\n\n            var id;\n\n            if ( ! this.getAttribute( 'id' )) {\n\n                id = preferredId;\n                while ( document.getElementById( id )) {\n                    id = preferredId + String( i );\n                    i++;\n                }\n                this.setAttribute( 'id', id );\n            }\n        });\n\n    };\n\n\n}( jQuery ));\n/*! HTML5 constraintValidationAPI - v1.0.7 - 2015-02-19\n * https://github.com/bboyle/html5-constraint-validation-API\n * Copyright (c) 2015 Ben Boyle; Licensed MIT */\n/*exported initConstraintValidationAPI*/\nif ( jQuery !== 'undefined' ) {\n    (function( $ ) {\n        'use strict';\n\n\n        // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address\n        // 1*( atext / \".\" ) \"@\" ldh-str 1*( \".\" ldh-str )\n        var REXP_EMAIL = /^[A-Za-z0-9!#$%&'*+\\-\\/=\\?\\^_`\\{\\|\\}~\\.]+@[A-Za-z0-9\\-]+(\\.[A-Za-z0-9\\-]+)*$/,\n\n        // fields that validate\n            candidateForValidation = 'input, select, textarea',\n\n        // for feature detection\n            input = $( '<input>' ).get( 0 ),\n\n        // polyfill test\n            polyfill = typeof input.validity !== 'object',\n\n        // radio button bug (google earth internal browser)\n            radioButtonBug = ! polyfill && $( '<input type=\"radio\" required checked>' ).get( 0 ).validity.valueMissing === true,\n            validateBuggyRadioButtons,\n\n        // invalid fields filter\n            isInvalid = function() {\n                return ! ( this.disabled || this.validity.valid );\n            },\n\n        // get all radio buttons\n            getRadioButtonsInGroup = function( radio ) {\n                return $( radio.form.elements[ radio.name ] ).filter( '[name=\"' + radio.name + '\"]' );\n            },\n\n\n        // manage validity state object\n            validityState = function( typeMismatch, valueMissing, customError, message, patternMismatch ) {\n\n                if ( typeof message === 'string' ) {\n                    customError = !! message;\n                }\n                return {\n                    customError: customError,\n                    typeMismatch: !! typeMismatch,\n                    patternMismatch: !! patternMismatch,\n                    valueMissing: !! valueMissing,\n                    valid: ! valueMissing && ! customError && ! typeMismatch && ! patternMismatch\n                };\n            },\n\n\n            validateField = function( message ) {\n\n                var $this = $( this ),\n                    required = !! $this.attr( 'required' ),\n                    radio = this.type === 'radio' && getRadioButtonsInGroup( this ),\n                    valueMissing,\n                    invalidEmail = this.getAttribute( 'type' ) === 'email' && !! this.value && ! REXP_EMAIL.test( this.value ),\n                    patternMismatch,\n                    pattern,\n                    newValidityState\n                    ;\n\n                // radio buttons are required if any single radio button is flagged as required\n                if ( radio && ! required ) {\n                    required = radio.filter( '[required]' ).length > 0;\n                }\n                // if required, check for missing value\n                if ( required ) {\n\n                    if ( /^select$/i.test( this.nodeName )) {\n                        valueMissing = this.selectedIndex === 0 && this.options[ 0 ].value === '';\n\n                    } else if ( radio ) {\n                        valueMissing = radio.filter( ':checked' ).length === 0;\n\n                    } else if ( this.type === 'checkbox' ) {\n                        valueMissing = ! this.checked;\n\n                    } else {\n                        valueMissing = ! this.value;\n                    }\n\n                }\n\n                if ( !! this.getAttribute( 'pattern' ) ) {\n                    if ( this.value.length > 0 ) {\n                        // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-input-element-attributes.html#compiled-pattern-regular-expression\n                        pattern = new RegExp( '^(?:' + this.getAttribute( 'pattern' ) + ')$' );\n\n                        patternMismatch = ! pattern.test( this.value );\n\n                    } else {\n                        patternMismatch = false;\n                    }\n                }\n\n                // set .validityState\n                newValidityState = validityState( invalidEmail, valueMissing, this.validity.customError || false, message, patternMismatch );\n                if ( radio ) {\n                    getRadioButtonsInGroup( this ).each(function() { this.validity = newValidityState; });\n                } else {\n                    this.validity = newValidityState;\n                }\n\n                // set .validationMessage\n                if ( this.validity.valid ) {\n                    this.validationMessage = '';\n\n                } else if ( this.validity.customError ) {\n                    if ( typeof message === 'string' ) {\n                        this.validationMessage = message;\n                    }\n\n                } else if ( this.validity.valueMissing ) {\n                    this.validationMessage = 'Please answer this question';\n\n                } else if ( this.validity.typeMismatch ) {\n                    this.validationMessage = 'Please type an email address';\n\n                } else if ( this.validity.patternMismatch ) {\n                    this.validationMessage = 'Please use the format shown';\n\n                } else {\n                    this.validationMessage = 'Please answer the question correctly';\n                }\n\n                return this.disabled || this.validity.valid;\n            },\n\n\n            changeHandler = function( event ) {\n                var target = event.target;\n\n                validateField.call( target );\n\n                if ( target.type === 'radio' ) {\n                    getRadioButtonsInGroup( target ).each(function() {\n                        this.validity = target.validity;\n                        this.validationMessage = target.validationMessage;\n                    });\n                }\n            },\n\n\n            submitHandler = function( event ) {\n\n                var form = $( this ),\n                    novalidate = !! form.attr( 'novalidate' ),\n                    invalid = false\n                    ;\n\n                // polyfill validation?\n                if ( polyfill ) {\n                    // check fields\n                    form.find( candidateForValidation ).each(function() {\n\n                        invalid = ! validateField.call( this );\n\n\n                        // unless @novalidate\n                        if ( ! novalidate ) {\n                            // if invalid\n                            if ( invalid ) {\n                                // use triggerHandler because invalid does not bubble\n                                $( this ).triggerHandler( 'invalid' );\n                            }\n                        }\n                    });\n                }\n\n                // NOTE all the code below runs in all browsers to polyfill implementation bugs\n\n                // required radio button check\n                if ( radioButtonBug ) {\n                    validateBuggyRadioButtons( this );\n                }\n\n                // Opera 11 on OSX fires submit event even when fields are invalid\n                // correct implementations will not invoke this submit handler until all fields are valid\n\n                // unless @novalidate\n                // if there are invalid fields\n                if ( ! novalidate && form.find( candidateForValidation ).filter( isInvalid ).length > 0 ) {\n                    // abort submit\n                    event.stopImmediatePropagation();\n                    event.preventDefault();\n                    return false;\n                }\n            },\n\n\n            initConstraintValidationAPI = function() {\n                var candidates = $( candidateForValidation );\n\n                // INPUT validityState\n                if ( polyfill ) {\n                    // set us up the API\n                    candidates.filter(function() {\n                        return typeof this.validity !== 'object';\n                    }).each(function() {\n\n                        this.validity = validityState( false, false, false, '', false );\n                        this.validationMessage = '';\n\n                    });\n\n                    // check validity on change\n                    candidates\n                        .unbind( 'change.constraintValidationAPI' )\n                        .bind( 'change.constraintValidationAPI', changeHandler )\n                    ;\n                }\n\n                // INPUT validitationMessage\n                if ( typeof input.validationMessage !== 'string' ) {\n                    // set us up the API\n                    candidates.filter(function() {\n                        return typeof this.validationMessage !== 'string';\n                    }).each(function() {\n                        this.validationMessage = '';\n                    });\n                }\n\n                // INPUT checkValidity\n                if ( typeof input.checkValidity !== 'function' ) {\n                    // set us up the API\n                    candidates.filter(function() {\n                        return typeof this.checkValidity !== 'function';\n                    }).each(function() {\n                        var domElement = this;\n\n                        this.checkValidity = function() {\n                            var valid = validateField.call( domElement );\n\n                            // if invalid, and unless novalidate\n                            if ( ! valid && ! this.form.getAttribute( 'novalidate' )) {\n                                // use triggerHandler because invalid does not bubble\n                                $( domElement ).triggerHandler( 'invalid' );\n                            }\n\n                            return valid;\n                        };\n                    });\n                }\n\n                // INPUT setCustomValidity\n                if ( typeof input.setCustomValidity !== 'function' ) {\n                    // set us up the API\n                    candidates.filter(function() {\n                        return typeof this.setCustomValidity !== 'function';\n                    }).each(function() {\n                        var that = this;\n\n                        this.setCustomValidity = function( message ) {\n                            validateField.call( that, message );\n                        };\n                    });\n                }\n\n                // check for required radio button bug (google earth internal browser)\n                if ( radioButtonBug ) {\n                    validateBuggyRadioButtons = function( form ) {\n                        var seen = {};\n                        var radio, valueMissing;\n\n                        // check every required radio button\n                        $( 'input', form ).filter( ':radio' ).filter( '[required],[aria-required=\"true\"]' ).each(function() {\n                            if ( typeof seen[ this.name ] === 'undefined' ) {\n                                seen[ this.name ] = true;\n\n                                radio = getRadioButtonsInGroup( this );\n                                valueMissing = radio.filter( ':checked' ).length === 0;\n\n                                if ( valueMissing ) {\n                                    // make sure @required is set to use validation API\n                                    radio.attr( 'required', 'required' );\n                                } else {\n                                    // using @aria-required=true so we can track this control\n                                    // removing @required here to bypass validation bug\n                                    radio.attr( 'aria-required', true ).removeAttr( 'required' );\n                                }\n                            }\n                        });\n                    };\n\n                    // initial validity\n                    $( 'form' ).each( validateBuggyRadioButtons );\n\n                    // watch changes\n                    if ( ! polyfill ) {\n                        candidates.filter( ':radio' )\n                            .unbind( 'change.constraintValidationAPI' )\n                            .bind( 'change.constraintValidationAPI', function() {\n                                validateBuggyRadioButtons( this.form );\n                            })\n                        ;\n                    }\n                }\n\n                // check validity on submit\n                // this should be bound before all other submit handlers bound to the same form\n                // otherwise they will execute before this handler can cancel submit (oninvalid)\n                $( 'form' )\n                    .unbind( 'submit.constraintValidationAPI' )\n                    .bind( 'submit.constraintValidationAPI', submitHandler )\n                ;\n            }\n            ;\n\n\n        // run immediately and ondocumentready\n        initConstraintValidationAPI();\n        $( initConstraintValidationAPI );\n\n\n        // expose init function\n        window.initConstraintValidationAPI = initConstraintValidationAPI;\n\n\n    }( jQuery ));\n}\n/*\n * jQuery Simply Countable plugin\n * Provides a character counter for any text input or textarea\n *\n * @version  0.4.2\n * @homepage http://github.com/aaronrussell/jquery-simply-countable/\n * @author   Aaron Russell (http://www.aaronrussell.co.uk)\n *\n * Copyright (c) 2009-2010 Aaron Russell (aaron@gc4.co.uk)\n * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)\n * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.\n */\n\n(function($){\n\n    $.fn.simplyCountable = function(options){\n\n        options = $.extend({\n            counter:            '#counter',\n            countType:          'characters',\n            maxCount:           140,\n            strictMax:          false,\n            countDirection:     'down',\n            safeClass:          'safe',\n            overClass:          'over',\n            thousandSeparator:  ',',\n            onOverCount:        function(){},\n            onSafeCount:        function(){},\n            onMaxCount:         function(){}\n        }, options);\n\n        var navKeys = [33,34,35,36,37,38,39,40];\n\n        return $(this).each(function(){\n\n            var countable = $(this);\n            var counter = $(options.counter);\n            if (!counter.length) { return false; }\n\n            var countCheck = function(){\n\n                var count;\n                var revCount;\n\n                var reverseCount = function(ct){\n                    return ct - (ct*2) + options.maxCount;\n                }\n\n                var countInt = function(){\n                    return (options.countDirection === 'up') ? revCount : count;\n                }\n\n                var numberFormat = function(ct){\n                    var prefix = '';\n                    if (options.thousandSeparator){\n                        ct = ct.toString();\n                        // Handle large negative numbers\n                        if (ct.match(/^-/)) {\n                            ct = ct.substr(1);\n                            prefix = '-';\n                        }\n                        for (var i = ct.length-3; i > 0; i -= 3){\n                            ct = ct.substr(0,i) + options.thousandSeparator + ct.substr(i);\n                        }\n                    }\n                    return prefix + ct;\n                }\n\n                var changeCountableValue = function(val){\n                    countable.val(val).trigger('change');\n                }\n\n                /* Calculates count for either words or characters */\n                if (options.countType === 'words'){\n                    count = options.maxCount - $.trim(countable.val()).split(/\\s+/).length;\n                    if (countable.val() === ''){ count += 1; }\n                }\n                else { count = options.maxCount - countable.val().length; }\n                revCount = reverseCount(count);\n\n                /* If strictMax set restrict further characters */\n                if (options.strictMax && count <= 0){\n                    var content = countable.val();\n                    if (count < 0) {\n                        options.onMaxCount(countInt(), countable, counter);\n                    }\n                    if (options.countType === 'words'){\n                        var allowedText = content.match( new RegExp('\\\\s?(\\\\S+\\\\s+){'+ options.maxCount +'}') );\n                        if (allowedText) {\n                            changeCountableValue(allowedText[0]);\n                        }\n                    }\n                    else { changeCountableValue(content.substring(0, options.maxCount)); }\n                    count = 0, revCount = options.maxCount;\n                }\n\n                counter.text(numberFormat(countInt()));\n\n                /* Set CSS class rules and API callbacks */\n                if (!counter.hasClass(options.safeClass) && !counter.hasClass(options.overClass)){\n                    if (count < 0){ counter.addClass(options.overClass); }\n                    else { counter.addClass(options.safeClass); }\n                }\n                else if (count < 0 && counter.hasClass(options.safeClass)){\n                    counter.removeClass(options.safeClass).addClass(options.overClass);\n                    options.onOverCount(countInt(), countable, counter);\n                }\n                else if (count >= 0 && counter.hasClass(options.overClass)){\n                    counter.removeClass(options.overClass).addClass(options.safeClass);\n                    options.onSafeCount(countInt(), countable, counter);\n                }\n\n            };\n\n            countCheck();\n\n            countable.on('keyup blur paste', function(e) {\n                switch(e.type) {\n                    case 'keyup':\n                        // Skip navigational key presses\n                        if ($.inArray(e.which, navKeys) < 0) { countCheck(); }\n                        break;\n                    case 'paste':\n                        // Wait a few miliseconds if a paste event\n                        setTimeout(countCheck, (e.type === 'paste' ? 5 : 0));\n                        break;\n                    default:\n                        countCheck();\n                        break;\n                }\n            });\n\n        });\n\n    };\n\n})(jQuery);/*! relevance - v2.1.0 - 2015-03-04\n * https://github.com/bboyle/relevance\n * Copyright (c) 2015 Ben Boyle; Licensed MIT */\nif ( jQuery !== 'undefined' ) {\n    (function( $ ) {\n        'use strict';\n\n        var relevantEvent = 'relevant',\n            irrelevantEvent = 'irrelevant',\n            elementsToDisable = 'button, input, select, textarea',\n            polyfillHidden = (function() {\n                var hidden = $( '<div hidden></div>' );\n                var hiddenSupported = hidden.appendTo( 'body' ).is( ':hidden' );\n                hidden.remove();\n                return ! hiddenSupported;\n            }()),\n\n            formElementsByName = function( form, name ) {\n                // filter out the @id matching of HTMLFormElement.elements[]\n                return $( form.elements[ name ] ).filter( '[name=\"' + name +'\"]' );\n            },\n\n            filterRelevant = function() {\n                return $( this ).closest( '[hidden]' ).length === 0;\n            },\n\n            filterIrrelevant = function() {\n                return $( this ).closest( '[hidden]' ).length > 0;\n            },\n\n            valueMap = function( element ) {\n                return element.value;\n            },\n\n            valueInArray = function( possibleValues, actualValues ) {\n                var i;\n                if ( typeof possibleValues !== 'object' ) {\n                    possibleValues = [ possibleValues ];\n                }\n\n                for ( i = 0; i < actualValues.length; i++ ) {\n                    if ( $.inArray( actualValues[ i ], possibleValues ) !== -1 ) {\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n\n        // when changing a control that alters relevance of other elements…\n            recalculateRelevance = function() {\n                // assume dependency map exists\n                var map = $( this.form ).data( 'relevance' ).dependencyMap[ this.name ],\n                    values = $.map( formElementsByName( this.form, this.name ).filter( 'select,:checked' ).filter( ':visible' ), valueMap )\n                    ;\n\n                $.each( map, function( index, config ) {\n                    config.items.relevance( 'relevant', valueInArray( config.values, values ) !== config.negate );\n                });\n            },\n\n        // when an element changes relevance, check descendent controls that alter relevance in turn…\n            recalculateDependents = function( isRelevant ) {\n                var form, dependencyMap, targets;\n\n                // any change to relevant toggles?\n                form = this.closest( 'form' );\n                if ( form.length ) {\n                    dependencyMap = form.data( 'relevance' );\n                    if ( typeof dependencyMap === 'object' ) {\n                        dependencyMap = dependencyMap.dependencyMap;\n                        if ( typeof dependencyMap === 'object' ) {\n                            // get descendent-or-self select, radio and checkbox\n                            targets = this.add( this.find( 'select,input' )).filter( 'select,:radio,:checkbox' );\n                            // get unique @name for select, radio and checkbox\n                            targets = $.unique( $.map( targets, function( elementOfArray ) {\n                                return elementOfArray.name;\n                            }));\n                            $.each( targets, function( index, name ) {\n                                var map = dependencyMap[ name ],\n                                    values;\n\n                                if ( typeof map === 'object' ) {\n                                    $.each( map, function( index, config ) {\n                                        if ( isRelevant === false ) {\n                                            config.items.relevance( 'relevant', false );\n\n                                        } else {\n                                            values = $.map( formElementsByName( form[ 0 ], name ).filter( 'select,:checked' ).filter( ':visible' ), valueMap );\n                                            config.items.relevance( 'relevant', valueInArray( config.values, values ) !== config.negate );\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n\n\n            methods = {\n\n                // $( x ).relevance( 'relevant', true )\n                // if the element is hidden, fire a 'relevant' event\n                // $( x ).relevance( 'relevant', false )\n                // if the element is visible, fire an \"irrelevant\" event\n                relevant: function( makeRelevant ) {\n                    var targets;\n                    if ( makeRelevant ) {\n                        targets = this.filter( filterIrrelevant ).trigger( relevantEvent );\n                    } else {\n                        targets = this.filter( filterRelevant ).trigger( irrelevantEvent );\n                    }\n                    if ( targets.length ) {\n                        recalculateDependents.call( targets, makeRelevant );\n                    }\n                    return this;\n                },\n\n                // $( x ).relevance( 'show' )\n                // shows the element (does not check if element is already visible)\n                // triggers 'relevant-done' after showing is complete\n                show: function() {\n\n                    // enable elements before they are shown\n                    this.add( this.find( elementsToDisable ))\n                    // but not any controls that will remain irrelevant\n                        .not( this.find( '[hidden]' ).find( elementsToDisable ))\n                        .each(function() {\n                            this.removeAttribute( 'disabled' );\n                        });\n\n                    // stop animation, remove @hidden and @aria-hidden, start showing\n                    if ( polyfillHidden ) {\n                        this.stop( true, true ).slideDown();\n                    }\n                    return this.removeAttr( 'hidden' ).removeAttr( 'aria-hidden' );\n                },\n\n                // $( x ).relevance( 'hide' )\n                // hides the element (does not check if element is already hidden)\n                hide: function() {\n\n                    this.attr({\n                        hidden: 'hidden',\n                        'aria-hidden': 'true'\n                    });\n\n                    if ( polyfillHidden ) {\n                        this.stop( true, true ).hide( 0, function() {\n                            var $this = $( this );\n                            // disable elements (including self if appropriate)\n                            $this.filter( elementsToDisable ).add( $this.find( elementsToDisable )).each(function() {\n                                this.setAttribute( 'disabled', 'disabled' );\n                            });\n                        });\n                    } else {\n                        this.filter( elementsToDisable ).add( this.find( elementsToDisable )).each(function() {\n                            this.setAttribute( 'disabled', 'disabled' );\n                        });\n                    }\n\n                    return this;\n                },\n\n                // $( x ).relevance( 'relevantWhen', { name: radio/checkbox/select, value: requiredValue, negate: false | true })\n                // sets up dependent relevance\n                // example: $( '#red' ).relevance( 'relevantWhen', { name: 'rgb', value: 'red' })\n                // example: $( '#red' ).relevance( 'relevantWhen', { id: 'rgb-red', value: 'red' })\n                // #red will be shown/hidden when '@name=rgb' value changes.\n                relevantWhen: function( config ) {\n                    var form, data, name, values;\n\n                    values = config.values || [ config.value ];\n\n                    if ( config.name ) {\n                        name = config.name;\n                    } else if ( config.id ) {\n                        name = document.getElementById( config.id ).name;\n                    } else if ( config.container ) {\n                        name = $( config.container ).find( 'select,:radio,:checkbox' ).attr( 'name' );\n                    }\n                    config.negate = config.negate === true;\n\n                    // find the form that has this control\n                    form = this.closest( 'form' );\n                    // get dependency map (create it if needed)\n                    data = form.data( 'relevance' );\n                    if ( typeof data !== 'object' ) {\n                        data = {};\n                        form.data( 'relevance', data );\n                    }\n                    if ( typeof data.dependencyMap !== 'object' ) {\n                        data.dependencyMap = {};\n                    }\n                    if ( typeof data.dependencyMap[ name ] !== 'object' ) {\n                        data.dependencyMap[ name ] = [];\n                        // setup event handlers for name\n                        formElementsByName( form[ 0 ], name )\n                            .filter( ':radio,:checkbox' )\n                            .bind( 'click', recalculateRelevance )\n                            .end()\n                            .filter( 'select' )\n                            .bind( 'change', recalculateRelevance )\n                        ;\n                    }\n                    // add or update relevance rule\n                    data.dependencyMap[ name ].push({\n                        items: this,\n                        values: values,\n                        negate: config.negate\n                    });\n\n                    // initial relevance\n                    this.relevance( 'relevant', valueInArray( values, $.map( formElementsByName( form[ 0 ], name ).filter( 'select,:checked' ).filter( ':visible' ), valueMap )) !== config.negate );\n\n                    return this;\n                },\n\n                // $( x ).relevance( 'instructions', options )\n                // sets up relevance handling based on text instructions\n                // options ::= { instructions: '.relevance', questions: '.questions > li' }\n                instructions: function( options ) {\n                    options = $.extend( {\n                        instructionSelector: '.relevance',\n                        questionSelector: '.questions > li'\n                    }, options );\n\n                    this.find( options.instructionSelector ).each(function() {\n                        var $this = $( this ),\n                            value = $this.text(),\n                            question = $this.closest( options.questionSelector ),\n                            toggle = question.prevAll( options.questionSelector ),\n                            i, answers, nestedToggles,\n                            match = false,\n                            negate = false\n                            ;\n\n                        // pattern: (If different to <PREVIOUS QUESTION>)\n                        if ( /If different to/.test( value )) {\n                            // assume previous 'li' is the toggle\n                            match = true;\n                            toggle = toggle.eq( 0 );\n                            value = toggle.find( ':checkbox' ).val();\n                            negate = true;\n                        } else {\n                            value = value.replace( /^.*chose\\s+\\S([^'\"’]+)\\S\\s+above.*$/, '$1' );\n                            // which of the previous questions is the toggle?\n                            i = 0;\n                            while ( i < toggle.length ) {\n                                // does this item have the answer we need?\n                                answers = $.map( toggle.eq( i ).find( 'option,:radio,:checkbox' ), valueMap );\n                                if ( valueInArray( value, answers )) {\n                                    nestedToggles = toggle.eq( i ).find( options.questionSelector );\n                                    if ( nestedToggles.length ) {\n                                        toggle = $( nestedToggles.get().reverse() );\n                                        i = 0;\n                                    } else {\n                                        match = true;\n                                        toggle = toggle.eq( i ); // toggle.length becomes 1, loop will exit\n                                        i = 1; // exit loop\n                                    }\n                                } else {\n                                    i++;\n                                }\n                            }\n                        }\n                        if ( match ) {\n                            toggle = toggle.add( toggle.find( 'select,input' )).filter( 'select,:radio,:checkbox' );\n                            question.relevance( 'relevantWhen', { name: toggle.attr( 'name' ), value: value, negate: negate });\n                        }\n                    });\n\n                    return this;\n                }\n\n            };\n\n\n        // fallback (default) event handling\n        $( document ).bind( 'relevant irrelevant', function( event ) {\n            var target = $( event.target );\n            if ( event.type === 'relevant' ) {\n                target.relevance( 'show' );\n            } else {\n                target.relevance( 'hide' );\n            }\n        });\n\n\n        $.fn.relevance = function( method ) {\n\n            // Method calling logic\n            // http://docs.jquery.com/Plugins/Authoring#Plugin_Methods\n            if ( methods[method] ) {\n                return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));\n            } else if ( typeof method === 'object' || ! method ) {\n                // return methods.init.apply( this, arguments );\n                return this;\n            } else {\n                $.error( 'Method ' +  method + ' does not exist on jQuery.relevance' );\n            }\n\n        };\n\n\n    }( jQuery ));\n}\n(function( $ ) {\n    'use strict';\n\n    // window.console.log( 'file-size-validation.js' );\n\n    var displayFileSize;\n\n\n    // bail out if no file API support\n    if ( typeof $( '<input type=\"file\">' )[ 0 ].files !== 'object' ) {\n        // duplicate fsize instruction before submit button\n        $( '.max-fsize' ).each(function() {\n            var fsize = $( this ), form;\n            form = fsize.closest( '.preamble' ).nextAll( 'form' ).eq( 0 );\n            form.find( '.actions' ).before( '<p>' + fsize.parent().html() + '</p>' );\n        });\n        return;\n    }\n\n\n    // display file size\n    displayFileSize = function( input ) {\n        input.nextAll( '.fsize' ).remove();\n        if ( input[ 0 ].files.length > 0 ) {\n            var filesize = input[ 0 ].files[ 0 ].size / 1024;\n\n            if ( filesize >= 1024 ) {\n                filesize = filesize / 1024;\n                input.after( '<span class=\"fsize\">File size: ' + ( Math.round( filesize * 10 ) / 10 ) + 'MB' + '</span>' );\n            } else {\n                input.after( '<span class=\"fsize\">File size: ' + ( Math.round( filesize * 10 ) / 10 ) + 'KB' + '</span>' );\n            }\n        }\n    };\n\n\n    // forms with max file size\n    $( '.max-fsize' ).each(function() {\n        var fsize = $( this ),\n            form,\n            maxFileSize\n            ;\n\n        // read fsize, assume MB\n        maxFileSize = parseInt( fsize.text().replace( /\\D+/g, '' ), 10 ) * 1024 * 1024;\n        // window.console.log( 'found max fsize', maxFileSize );\n\n        // get form (closest form after the preamble)\n        form = fsize.closest( '.preamble' ).nextAll( 'form' ).eq( 0 );\n\n        form.find( ':file' ).on( 'change', function() {\n            var input = $( this );\n\n            displayFileSize( input );\n\n            // recalculate file sizes\n            var total = 0, valid;\n            $( ':file', this.form ).each(function( index, element ) {\n                var size = element.files.length ? element.files[ 0 ].size : 0;\n                total += size; // total = total + size;\n            });\n\n            // is everything valid or invalid?\n            valid = total <= maxFileSize;\n\n            // window.console.info( 'file size validation:', total, '<', maxFileSize, total < maxFileSize );\n\n            $( ':file', this.form )\n            // update validity for :file inputs with values\n                .filter(function() {\n                    return !! this.value;\n                })\n                .each(function( index, element ) {\n                    element.setCustomValidity( valid ? '' : 'Attachments are too large' );\n                })\n                // blank :file inputs should not have a custom error\n                .filter(function() {\n                    return ! this.value;\n                })\n                .each(function( index, element ) {\n                    element.setCustomValidity( '' );\n                });\n\n        });\n\n    });\n\n}( jQuery ));\n(function( $ ) {\n    'use strict';\n\n    var xorConstraintSubmitHandler = function( event ) {\n            // has one of the required fields been answered?\n            var xorFields = event.data[ 0 ],\n                validationMessage = event.data[ 1 ],\n                xorConstraintMet = xorFields.filter(function() {\n                        return this.value.length > 1;\n                    }).length > 0\n                ;\n\n            xorFields.each(function() {\n                this.setCustomValidity(\n                    xorConstraintMet ? '' : validationMessage\n                );\n            });\n        },\n\n        xorConstraintChangeHandler = function( event, validationUiRefreshOnly ) {\n            if ( validationUiRefreshOnly === true ) {\n                // pass through to other change handlers\n                return;\n            }\n\n            var xorFields = event.data[ 0 ];\n\n            // constraint validity check\n            xorConstraintSubmitHandler( event );\n\n            // trigger validation UI  on other fields?\n            if ( event.type === 'change' ) {\n                xorFields.not( event.target ).triggerHandler( 'change', true );\n            }\n        }\n        ;\n\n\n    // plugin\n    $.fn.initXorConstraint = function( validationMessage ) {\n        // custom validation for XOR options\n        this.closest( 'form' ).on( 'submit', [ this, validationMessage ], xorConstraintSubmitHandler );\n        this.on( 'change', [ this, validationMessage ], xorConstraintChangeHandler );\n    };\n\n\n}( jQuery ));\n/**\n * This file initialises forms\n */\n(function( $ ) { /* start closure */\n    'use strict';\n\n\n    var initValidation = function() {\n        window.initConstraintValidationAPI();\n        $( 'form' ).formValidation( 'validate' );\n    };\n\n\n    // now: hookup form validation\n    initValidation();\n\n    // document ready: hookup form validation\n    $( initValidation );\n\n\n    // instruction based relevance\n    if ( $( '.relevance', 'form' ).length > 0 ) {\n        $( 'form', '#content' ).relevance( 'instructions' );\n    }\n\n\n}( jQuery )); /* end closure */\n(function( $ ){\n    'use strict';\n\n\n    // extend jquery to 'toggle required'\n    $.fn.toggleRequired = function( required ) {\n        return this.each(function() {\n\n            var controls = $( this.form.elements[ this.name ] ),\n                question = $( this ).closest( '.questions > li' )\n                ;\n\n            if ( required ) {\n                if ( question.find( 'abbr[title=\"(required)\"]' ).length === 0 ) {\n                    question.find( '.label' ).after(\n                        // create ABBR shiv for IE6\n                        $( document.createElement( 'abbr' ))\n                            .attr( 'title' , '(required)' )\n                            .text( '*' )\n                            .addClass( 'required' )\n                    );\n                }\n                controls.attr( 'required', 'required' );\n            } else {\n                controls.removeAttr( 'required' );\n                question.find( 'abbr[title=\"(required)\"]' ).remove();\n            }\n        });\n    };\n\n\n}( jQuery ));\n/*globals qg*/\n// globals\nvar qg = { oldIE: false }\nqg.date = (function() {\n    'use strict';\n\n\n    var datePackage = {},\n\n    // Public holiday dates for 2010-2014 (viewed 2012-09-28)\n    // http://www.justice.qld.gov.au/fair-and-safe-work/industrial-relations/public-holidays/dates\n        qldHolidays = {\n            // 2010\n            '2010-01-01' : 'New Year’s Day',\n            '2010-01-26' : 'Australia Day',\n            '2010-04-02' : 'Good Friday',\n            '2010-04-03' : 'Easter Saturday',\n            '2010-04-05' : 'Easter Monday',\n            '2010-04-26' : 'Anzac Day',\n            '2010-05-03' : 'Labour Day',\n            '2010-06-14' : 'Queen’s Birthday',\n            '2010-12-25' : 'Christmas Day',\n            '2010-12-27' : 'Boxing Day',\n            '2010-12-28' : 'Christmas Day holiday',\n\n            // 2011\n            '2011-01-01' : 'New Year’s Day',\n            '2011-01-03' : 'New Year’s Day holiday',\n            '2011-02-26' : 'Australia Day',\n            '2011-04-22' : 'Good Friday',\n            '2011-04-23' : 'Easter Saturday',\n            '2011-04-25' : 'Anzac Day',\n            '2011-04-26' : 'Easter Monday',\n            '2011-05-02' : 'Labour Day',\n            '2011-06-13' : 'Queen’s Birthday',\n            '2011-12-25' : 'Christmas Day',\n            '2011-12-26' : 'Boxing Day',\n            '2011-12-27' : 'Christmas Day holiday',\n\n            // 2012\n            '2012-01-01' : 'New Year’s Day',\n            '2012-01-02' : 'New Year’s Day holiday',\n            '2012-02-26' : 'Australia Day',\n            '2012-04-06' : 'Good Friday',\n            '2012-04-07' : 'Easter Saturday',\n            '2012-04-09' : 'Easter Monday',\n            '2012-04-25' : 'Anzac Day',\n            '2012-05-07' : 'Labour Day',\n            '2012-06-11' : 'Queen’s Diamond Jubilee',\n            '2012-10-01' : 'Queen’s Birthday',\n            '2012-12-25' : 'Christmas Day',\n            '2012-12-26' : 'Boxing Day',\n\n            // 2013\n            '2013-01-01' : 'New Year’s Day',\n            '2013-01-28' : 'Australia Day holiday',\n            '2013-03-29' : 'Good Friday',\n            '2013-03-30' : 'Easter Saturday',\n            '2013-04-01' : 'Easter Monday',\n            '2013-04-25' : 'Anzac Day',\n            '2013-06-10' : 'Queen’s Birthday',\n            '2013-10-07' : 'Labour Day',\n            '2013-12-25' : 'Christmas Day',\n            '2013-12-26' : 'Boxing Day',\n\n            // 2014\n            '2014-01-01' : 'New Year’s Day',\n            '2014-01-27' : 'Australia Day holiday',\n            '2014-04-18' : 'Good Friday',\n            '2014-04-19' : 'Easter Saturday',\n            '2014-04-21' : 'Easter Monday',\n            '2014-04-25' : 'Anzac Day',\n            '2014-06-09' : 'Queen’s Birthday',\n            '2014-10-06' : 'Labour Day',\n            '2014-12-25' : 'Christmas Day',\n            '2014-12-26' : 'Boxing Day',\n\n            // 2015\n            '2015-01-01' : 'New Year’s Day',\n            '2015-01-26' : 'Australia Day holiday',\n            '2015-04-03' : 'Good Friday',\n            '2015-04-04' : 'Easter Saturday',\n            '2015-04-06' : 'Easter Monday',\n            '2015-04-25' : 'Anzac Day',\n            '2015-06-08' : 'Queen’s Birthday',\n            '2015-10-05' : 'Labour Day',\n            '2015-12-25' : 'Christmas Day',\n            '2015-12-26' : 'Boxing Day',\n            '2015-12-28' : 'Boxing Day holiday',\n\n            // 2016\n            '2016-01-01' : 'New Year’s Day',\n            '2016-01-26' : 'Australia Day holiday',\n            '2016-03-25' : 'Good Friday',\n            '2016-03-26' : 'Easter Saturday',\n            '2016-03-28' : 'Easter Monday',\n            '2016-04-25' : 'Anzac Day',\n            '2016-06-13' : 'Queen’s Birthday',\n            '2016-10-03' : 'Labour Day',\n            '2016-12-25' : 'Christmas Day',\n            '2016-12-27' : 'Christmas Day holiday',\n            '2016-12-26' : 'Boxing Day',\n\n            // 2017\n            '2017-01-01' : 'New Year’s Day',\n            '2017-01-02' : 'New Year’s Day holiday',\n            '2017-01-26' : 'Australia Day holiday',\n            '2017-04-14' : 'Good Friday',\n            '2017-04-15' : 'Easter Saturday',\n            '2017-04-17' : 'Easter Monday',\n            '2017-04-25' : 'Anzac Day',\n            '2017-06-12' : 'Queen’s Birthday',\n            '2017-10-02' : 'Labour Day',\n            '2017-12-25' : 'Christmas Day',\n            '2017-12-26' : 'Boxing Day',\n\n            // 2018\n            '2018-01-01' : 'New Year’s Day',\n            '2018-01-26' : 'Australia Day holiday',\n            '2018-03-30' : 'Good Friday',\n            '2018-03-31' : 'Easter Saturday',\n            '2018-04-02' : 'Easter Monday',\n            '2018-04-25' : 'Anzac Day',\n            '2018-05-07' : 'Labour Day',\n            '2018-10-01' : 'Queen’s Birthday',\n            '2018-12-25' : 'Christmas Day',\n            '2018-12-26' : 'Boxing Day'\n        }\n        ;\n\n\n    // is a public holiday\n    datePackage.isPublicHoliday = function( date ) {\n        var d = date.getDate(),\n            m = date.getMonth() + 1,\n            y = String( date.getFullYear() ),\n            dateString = y + ( m < 10 ? '-0' : '-' ) + m + ( d < 10 ? '-0' : '-' ) + d\n            ;\n\n        // return true, date is a public holiday\n        // TODO, if not a state-wide public holiday and given a latlong, check if it is a show holiday\n        // return false, date is not a public holiday\n        // TODO\n        // return undefined, it is not known if the date is a public holiday (beyond 2 years in the future?)\n\n        return !! qldHolidays[ dateString ];\n    };\n\n\n    return datePackage;\n\n}());\n(function( $ ){\n    'use strict';\n\n\n    // find any textareas with a word count\n    $( '.hint' ).filter(function() {\n        return ( /Maximum:\\s+\\d+\\s+words/ ).test( $( this ).text() );\n    }).each(function() {\n        var hint = $( this ),\n            max = parseInt( hint.text().replace( /Maximum:\\s+(\\d+)\\s+words/, '$1' ), 10 ),\n            textField = hint.closest( 'label' ).nextAll( 'textarea' ),\n            counter\n            ;\n\n        // add counter\n        counter = $( '<span/>' ).generateId( 'word-count' );\n        //eg. Maximum: 50 words (50 remaining)\n        hint.append( ' (', counter, ' remaining)' );\n\n        textField.simplyCountable({\n            counter: '#' + counter[ 0 ].id,\n            countType: 'words',\n            countDirection: 'down',\n            maxCount: max,\n            onOverCount: function() {\n                textField[ 0 ].setCustomValidity( 'Too many words' );\n            },\n            onSafeCount: function() {\n                textField[ 0 ].setCustomValidity( '' );\n            }\n        });\n    });\n\n\n}( jQuery ));\n\n//# sourceMappingURL=qg-forms.js.map\n"],"sourceRoot":"src/assets/js/"}